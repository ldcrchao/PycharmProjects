#%%
# -*- coding UTF-8 -*-
'''
@Project : python学习工程文件夹
@File : SVM_doc.py
@Author : chenbei
@Date : 2020/12/17 16:42
'''
# 参数说明
#- C：类似于Logistic regression中的正则化系数，必须为正的浮点数，默认为 1.0，这个值越小，说明正则化效果越强。换句话说，这个值越小，越训练的模型更泛化，但也更容易欠拟合。
#- kernel：核函数选择，比较复杂，稍后介绍
#- degree：多项式阶数，仅在核函数选择多项式（即“poly”）的时候才生效，int类型，默认为3。
#- gamma：核函数系数，仅在核函数为高斯核，多项式核，Sigmoid核（即“rbf“，“poly“ ，“sigmoid“）时生效。float类型，默认为“auto”（即值为 1 / n_features）。
#- coef0：核函数的独立项，仅在核函数为多项式核核Sigmoid核（即“poly“ ，“sigmoid“）时生效。float类型，默认为0.0。独立项就是常数项。
#- shrinking：不断缩小的启发式方法可以加快优化速度。 就像在FAQ中说的那样，它们有时会有所帮助，有时却没有帮助。 我认为这是运行时问题，而不是收敛问题。
#- probability：是否使用概率评估，布尔类型，默认为False。开启的话会评估数据到每个分类的概率，不过这个会使用到较多的计算资源，慎用！！
#- tol：停止迭代求解的阈值，单精度类型，默认为1e-3。逻辑回归也有这样的一个参数，功能都是一样的。
#- cache_size：指定使用多少内存来运行，浮点型，默认200，单位是MB。
#- class_weight：分类权重，也是和逻辑回归的一样，我直接就搬当时的内容了：分类权重，可以是一个dict（字典类型），也可以是一个字符串"balanced"字符串。默认是None，也就是不做任何处理，而"balanced"则会去自动计算权重，分类越多的类，权重越低，反之权重越高。也可以自己输出一个字典，比如一个 0/1 的二元分类，可以传入{0:0.1,1:0.9}，这样 0 这个分类的权重是0.1，1这个分类的权重是0.9。这样的目的是因为有些分类问题，样本极端不平衡，比如网络攻击，大部分正常流量，小部分攻击流量，但攻击流量非常重要，需要有效识别，这时候就可以设置权重这个参数。
#- verbose：输出详细过程，int类型，默认为0（不输出）。当大于等于1时，输出训练的详细过程。仅当"solvers"参数设置为"liblinear"和"lbfgs"时有效。
#- max_iter：最大迭代次数，int类型，默认-1（即无限制）。注意前面也有一个tol迭代限制，但这个max_iter的优先级是比它高的，也就如果限制了这个参数，那是不会去管tol这个参数的。
#- decision_function_shape：多分类的方案选择，有“ovo”，“ovr”两种方案，也可以选则“None”，默认是“ovr”，详细区别见下面。
#- random_state：随时数种子。
# 属性说明
# AUC = 1 是完美分类器，采用这个预测模型时，存在至少一个阈值能得出完美预测。绝大多数预测的场合，不存在完美分类器。
# 0.5 < AUC < 1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。
# AUC < 0.5，比随机猜测还差；但只要总是反预测而行，就优于随机猜测。